{"version":3,"sources":["interp.js"],"names":[],"mappings":"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","file":"interp.js","sourcesContent":["const C = require('./constants')\nconst lib = require('./lib')\nconst chalk = require('chalk')\nconst builtins = require('./builtins')\n\nif (!(console.group)) {\n  try {\n    require('console-group').install()\n  } catch(err) {\n    console.group = function(msg) {\n      console.log(chalk.cyan(`Group: ${msg}`))\n    }\n    console.groupEnd = function() {\n      console.log(chalk.cyan('Group end'))\n    }\n  }\n}\n\nexport async function evaluateExpression(expression, environment) {\n  // console.group(`Evaluate in environment ${environment}\\n`, expression)\n  const returnVal = await async function() {\n    if (expression[0] === C.COMMENT) {\n      return\n    } else if (expression instanceof Array &&\n               expression.every(e => e instanceof Array)) {\n      const ret = await evaluateEachExpression(expression, environment)\n      return ret\n    }\n\n    if (expression[0] === C.VARIABLE_IDENTIFIER && expression[1] === 'environment') {\n      return environment\n    } else if (expression[0] === C.FUNCTION_CALL) {\n      // Call a function: \"function(arg1, arg2, arg3...)\"\n\n      // Get the function and argument expressions from the expression list.\n      const fnExpression = expression[1]\n      const argExpressions = expression[2]\n\n      // Evaluate the function expression to get the actual function.\n      const fn = await evaluateExpression(fnExpression, environment)\n      const varName = fnExpression[1]\n\n      if (!(fn instanceof lib.LFunction)) {\n        throw new Error(`${chalk.cyan(varName)} is not a function`)\n      }\n\n      fn.argumentScope = environment\n      const args = argExpressions\n      const takingArgs = fn.paramaterList || []\n\n      // We need to discuss this... what's fn.builtin? This also should make sure\n      // that the called function is not a JS function, because you can't really\n      // get the number of paramaters from JS functions.\n      // if (args.length !== takingArgs.length && !fn.builtin) {\n      //   throw new Error(`Function ${chalk.cyan(varName)} expects ${chalk.bold(takingArgs.length)} arguments, was called with ${chalk.bold(args.length)}`)\n      // }\n\n      // Use lib.call to call the function with the evaluated arguments.\n      return await lib.call(fn, args)\n    } else if (expression[0] === C.VARIABLE_IDENTIFIER) {\n      // Get a variable: \"name\"\n\n      // Get the name from the expression list.\n      const name = expression[1]\n\n      // Return the variable's value, or, if the variable doesn't exist, throw an\n      // error.\n      if (environment.vars.hasOwnProperty(name)) {\n        const ret = environment.vars[name].value\n        return ret\n      } else {\n        throw new Error(`${chalk.cyan(name)} is not defined in ${Object.keys(environment.vars)}`)\n      }\n    } else if (expression[0] === C.VARIABLE_ASSIGN) {\n      // Set a variable to a value: \"name => value\"\n\n      // Get the name and value expression from the expression list.\n      const name = expression[1]\n      const valueExpression = expression[2]\n\n      // console.log(`Setting variable ${name}...`)\n\n      // Evaluate the value of the variable.\n      const value = await evaluateExpression(valueExpression, environment)\n\n      // console.log(`..value is ${value}`)\n\n      // Set the variable in the variables object to a new variable with the\n      // evaluated value.\n      environment.vars[name] = new lib.Variable(value)\n      return\n    } else if (expression[0] === C.VARIABLE_CHANGE) {\n      // Change a variable to a new value: \"name -> newValue\"\n\n      // Get the name and value expression from the expression list.\n      const name = expression[1]\n      const valueExpression = expression[2]\n\n      // Evaluate the new value of the variable.\n      const value = await evaluateExpression(valueExpression, environment)\n\n      // Change the value of the already defined variable.\n      environment.vars[name].value = value\n      return\n    } else if (expression[0] === C.FUNCTION_PRIM) {\n      // A function literal: \"[async] [(arg1, arg2, arg3...)] { code }\"\n\n      // Get the code and paramaters from the expression list.\n      const paramaters = expression[1]\n      const code = expression[2]\n      const isAsync = expression[3]\n\n      // Create the function using the given code.\n      const fn = new lib.LFunction(code)\n\n      // Set the scope variables for the function to a copy of the current\n      // variables.\n      fn.environment = new lib.LEnvironment()\n      fn.environment.parentEnvironment = environment\n      fn.environment.comment = 'Function environment'\n      fn.environment.addVars(environment.vars)\n\n      // Set the paramaters for the function to the paramaters taken from the\n      // expression list.\n      fn.setParamaters(paramaters)\n\n      fn.isAsynchronous = isAsync\n\n      // Return the function.\n      return fn\n    } else if (expression[0] === C.SHORTHAND_FUNCTION_PRIM) {\n      // >> OUTDATED CODE <<\n      const paramaters = expression[1]\n      const codeExpression = expression[2]\n      const fn = new lib.LFunction(codeExpression)\n      fn.isShorthand = true\n      fn.setScopeVariables(Object.assign({}, environment))\n      fn.setParamaters(paramaters)\n      return fn\n    } else if (expression[0] === C.STRING_PRIM) {\n      // String literal: \"contents\"\n\n      // Get string from expression list.\n      const string = expression[1]\n\n      // Convert string to a language-usable string, and return.\n      return lib.toLString(string)\n    } else if (expression[0] === C.BOOLEAN_PRIM) {\n      // Boolean literal: true/false\n\n      // Get boolean value from expression list.\n      const bool = expression[1]\n\n      // Convert boolean value to a language-usable boolean, and return.\n      return lib.toLBoolean(bool)\n    } else if (expression[0] === C.NUMBER_PRIM) {\n      // Number primitive: 1, 2, 3, 4, 7.25, -3, etc.\n\n      // Get number value from expression list.\n      const number = expression[1]\n\n      // Convert number value to a language-usable number, and return.\n      return lib.toLNumber(number)\n    } else if (expression[0] === C.SET_PROP_USING_IDENTIFIER) {\n      // Set a property of an object using an identifier literal:\n      // \"obj.key > value\"\n\n      // Get object expression, key, and value expression from expression list.\n      const objExpression = expression[1]\n      const key = expression[2]\n      const valueExpression = expression[3]\n\n      // Evaluate the object and value expressions.\n      const obj = await evaluateExpression(objExpression, environment)\n      const value = await evaluateExpression(valueExpression, environment)\n\n      // Use lib.set to set the property of the evaluated object.\n      lib.set(obj, key, value)\n\n      return\n    } else if (expression[0] === C.GET_PROP_USING_IDENTIFIER) {\n      // Get a property of an object using an identifier literal: \"obj.key\"\n\n      // Get object expression and key from the expression list.\n      const objExpression = expression[1]\n      const key = expression[2]\n\n      // Evaluate the object expression.\n      const obj = await evaluateExpression(objExpression, environment)\n\n      // Get the value from lib.get.\n      const value = lib.get(obj, key)\n\n      // Return the gotten value.\n      return value\n    } else {\n      throw new Error(`Invalid expression: ${chalk.cyan(expression[0])}`)\n    }\n  }()\n  // console.log(chalk.bold('Return value: ' + returnVal))\n  // console.groupEnd()\n  return returnVal\n}\n\nexport async function evaluateGetPropUsingIdentifier(variables, [_, objExpr, key]) {\n  let obj = await evaluateExpression(objExpr, variables)\n  return lib.get(obj, key)\n}\n\nexport async function evaluateEachExpression(expressions, environment) {\n  function checkBreak() {\n    let breakEnv = environment.breakToEnvironment\n    if (breakEnv !== null) {\n      if (breakEnv !== environment.parentEnvironment) {\n        environment.parentEnvironment.breakToEnvironment = breakEnv\n      }\n      return true\n    }\n    return false\n  }\n\n  if (checkBreak()) return []\n\n  let results = []\n  for (let expression of expressions) {\n    results.push(await evaluateExpression(expression, environment))\n    if (checkBreak()) break\n  }\n\n  return results\n}\n\nexport async function interp(ast, dir) {\n  if (ast) {\n    const environment = new lib.LEnvironment()\n\n    environment.comment = 'Master environment'\n\n    environment.addVars(builtins.makeBuiltins(dir))\n\n    let result = await evaluateEachExpression(ast, environment)\n\n    return { result, environment }\n  } else {\n    throw new Error('Haha, you didn\\'t pass me a tree!')\n  }\n}\n"],"sourceRoot":"/source/"}