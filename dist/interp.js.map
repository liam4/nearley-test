{"version":3,"sources":["interp.js"],"names":[],"mappings":"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","file":"interp.js","sourcesContent":["const C = require('./constants')\nconst lib = require('./lib')\nconst chalk = require('chalk')\nconst builtins = require('./builtins')\n\nexport async function evaluateExpression(expression, environment) {\n  // console.log('evaluating expression', expression)\n  if (expression[0] === C.COMMENT) {\n    return\n  } else if (expression instanceof Array &&\n             expression.every(e => e instanceof Array)) {\n    const ret = await evaluateEachExpression(expression, environment)\n    return ret\n  } if (expression[0] === C.VARIABLE_IDENTIFIER && expression[1] === 'environment') {\n    return environment\n  } else if (expression[0] === C.FUNCTION_CALL) {\n    // Call a function: \"function(arg1, arg2, arg3...)\"\n\n    // Get the function and argument expressions from the expression list.\n    const fnExpression = expression[1]\n    const argExpressions = expression[2]\n\n    // Evaluate the function expression to get the actual function.\n    const fn = await evaluateExpression(fnExpression, environment)\n    const varName = fnExpression[1]\n\n    if (!(fn instanceof lib.LFunction)) {\n      throw new Error(`${chalk.cyan(varName)} is not a function`)\n    }\n\n    fn.argumentScope = environment\n    const args = argExpressions\n    const takingArgs = fn.paramaterList || []\n\n    // We need to discuss this... what's fn.builtin? This also should make sure\n    // that the called function is not a JS function, because you can't really\n    // get the number of paramaters from JS functions.\n    // if (args.length !== takingArgs.length && !fn.builtin) {\n    //   throw new Error(`Function ${chalk.cyan(varName)} expects ${chalk.bold(takingArgs.length)} arguments, was called with ${chalk.bold(args.length)}`)\n    // }\n\n    // Use lib.call to call the function with the evaluated arguments.\n    return await lib.call(fn, args)\n  } else if (expression[0] === C.VARIABLE_IDENTIFIER) {\n    // Get a variable: \"name\"\n\n    // Get the name from the expression list.\n    const name = expression[1]\n\n    // Return the variable's value, or, if the variable doesn't exist, throw an\n    // error.\n    if (environment.vars.hasOwnProperty(name)) {\n      const ret = environment.vars[name].value\n      return ret\n    } else {\n      throw new Error(`${chalk.cyan(name)} is not defined in ${Object.keys(environment.vars)}`)\n    }\n  } else if (expression[0] === C.VARIABLE_ASSIGN) {\n    // Set a variable to a value: \"name => value\"\n\n    // Get the name and value expression from the expression list.\n    const name = expression[1]\n    const valueExpression = expression[2]\n\n    // console.log(`Setting variable ${name}...`)\n\n    // Evaluate the value of the variable.\n    const value = await evaluateExpression(valueExpression, environment)\n\n    // console.log(`..value is ${value}`)\n\n    // Set the variable in the variables object to a new variable with the\n    // evaluated value.\n    environment.vars[name] = new lib.Variable(value)\n    return\n  } else if (expression[0] === C.VARIABLE_CHANGE) {\n    // Change a variable to a new value: \"name -> newValue\"\n\n    // Get the name and value expression from the expression list.\n    const name = expression[1]\n    const valueExpression = expression[2]\n\n    // Evaluate the new value of the variable.\n    const value = await evaluateExpression(valueExpression, environment)\n\n    // Change the value of the already defined variable.\n    environment.vars[name].value = value\n    return\n  } else if (expression[0] === C.FUNCTION_PRIM) {\n    // A function literal: \"[async] [(arg1, arg2, arg3...)] { code }\"\n\n    // Get the code and paramaters from the expression list.\n    const paramaters = expression[1]\n    const code = expression[2]\n    const isAsync = expression[3]\n\n    // Create the function using the given code.\n    const fn = new lib.LFunction(code)\n\n    // Set the scope variables for the function to a copy of the current\n    // variables.\n    fn.environment = new lib.LEnvironment()\n    fn.environment.addVars(environment.vars)\n\n    // Set the paramaters for the function to the paramaters taken from the\n    // expression list.\n    fn.setParamaters(paramaters)\n\n    fn.isAsynchronous = isAsync\n\n    // Return the function.\n    return fn\n  } else if (expression[0] === C.SHORTHAND_FUNCTION_PRIM) {\n    // >> OUTDATED CODE <<\n    const paramaters = expression[1]\n    const codeExpression = expression[2]\n    const fn = new lib.LFunction(codeExpression)\n    fn.isShorthand = true\n    fn.setScopeVariables(Object.assign({}, environment))\n    fn.setParamaters(paramaters)\n    return fn\n  } else if (expression[0] === C.STRING_PRIM) {\n    // String literal: \"contents\"\n\n    // Get string from expression list.\n    const string = expression[1]\n\n    // Convert string to a language-usable string, and return.\n    return lib.toLString(string)\n  } else if (expression[0] === C.BOOLEAN_PRIM) {\n    // Boolean literal: true/false\n\n    // Get boolean value from expression list.\n    const bool = expression[1]\n\n    // Convert boolean value to a language-usable boolean, and return.\n    return lib.toLBoolean(bool)\n  } else if (expression[0] === C.NUMBER_PRIM) {\n    // Number primitive: 1, 2, 3, 4, 7.25, -3, etc.\n\n    // Get number value from expression list.\n    const number = expression[1]\n\n    // Convert number value to a language-usable number, and return.\n    return lib.toLNumber(number)\n  } else if (expression[0] === C.SET_PROP_USING_IDENTIFIER) {\n    // Set a property of an object using an identifier literal:\n    // \"obj.key > value\"\n\n    // Get object expression, key, and value expression from expression list.\n    const objExpression = expression[1]\n    const key = expression[2]\n    const valueExpression = expression[3]\n\n    // Evaluate the object and value expressions.\n    const obj = await evaluateExpression(objExpression, environment)\n    const value = await evaluateExpression(valueExpression, environment)\n\n    // Use lib.set to set the property of the evaluated object.\n    lib.set(obj, key, value)\n\n    return\n  } else if (expression[0] === C.GET_PROP_USING_IDENTIFIER) {\n    // Get a property of an object using an identifier literal: \"obj.key\"\n\n    // Get object expression and key from the expression list.\n    const objExpression = expression[1]\n    const key = expression[2]\n\n    // Evaluate the object expression.\n    const obj = await evaluateExpression(objExpression, environment)\n\n    // Get the value from lib.get.\n    const value = lib.get(obj, key)\n\n    // Return the gotten value.\n    return value\n  } else {\n    throw new Error(`Invalid expression: ${chalk.cyan(expression[0])}`)\n  }\n}\n\nexport async function evaluateGetPropUsingIdentifier(variables, [_, objExpr, key]) {\n  let obj = await evaluateExpression(objExpr, variables)\n  return lib.get(obj, key)\n}\n\nexport async function evaluateEachExpression(expressions, environment) {\n  let results = []\n  for (let expression of expressions) {\n    results.push(await evaluateExpression(expression, environment))\n  }\n  return results\n}\n\nexport async function interp(ast, dir) {\n  if (ast) {\n    const environment = new lib.LEnvironment()\n\n    environment.addVars(builtins.makeBuiltins(dir))\n\n    let result = await evaluateEachExpression(ast, environment)\n\n    return { result, environment }\n  } else {\n    throw new Error('Haha, you didn\\'t pass me a tree!')\n  }\n}\n"],"sourceRoot":"/source/"}