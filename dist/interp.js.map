{"version":3,"sources":["interp.js"],"names":[],"mappings":"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","file":"interp.js","sourcesContent":["const C = require('./constants')\nconst lib = require('./lib')\nconst chalk = require('chalk')\nconst builtins = require('./builtins')\n\nexport async function evaluateExpression(expression, environment) {\n  // console.log('evaluating expression', expression)\n  if (expression[0] === C.COMMENT) {\n    return\n  } else if (expression instanceof Array &&\n             expression.every(e => e instanceof Array)) {\n    // console.log('Fo...')\n    const ret = await evaluateEachExpression(variables, expression)\n    // console.log('Ba.', ret)\n    return ret\n  } if (expression[0] === C.VARIABLE_IDENTIFIER && expression[1] === 'environment') {\n    /*\n    const env = new lib.LEnvironment()\n    env.addVars(variables)\n    return env\n    */\n    return environment\n  } else if (expression[0] === C.FUNCTION_CALL) {\n    // Call a function: \"function(arg1, arg2, arg3...)\"\n\n    // Get the function and argument expressions from the expression list.\n    const fnExpression = expression[1]\n    const argExpressions = expression[2]\n\n    // Evaluate the function expression to get the actual function.\n    const fn = await evaluateExpression(fnExpression, variables)\n    const varName = fnExpression[1]\n\n    if (!(fn instanceof lib.LFunction)) {\n      throw new Error(`${chalk.cyan(varName)} is not a function`)\n    }\n\n    fn.argumentScope = variables\n    const args = argExpressions\n    const takingArgs = fn.paramaterList || []\n\n    if (args.length !== takingArgs.length && !fn.builtin) {\n      throw new Error(`Function ${chalk.cyan(varName)} expects ${chalk.bold(takingArgs.length)} arguments, was called with ${chalk.bold(args.length)}`)\n    }\n\n    // Use lib.call to call the function with the evaluated arguments.\n    return await lib.call(fn, args)\n  } else if (expression[0] === C.VARIABLE_IDENTIFIER) {\n    // Get a variable: \"name\"\n\n    // Get the name from the expression list.\n    const name = expression[1]\n\n    // console.log(`Getting variable ${name}...`)\n    // console.log(name in variables)\n\n    // Return the variable's value, or, if the variable doesn't exist, throw an\n    // error.\n    if (name in variables) {\n      // console.log('Return:', variables[name])\n      const ret = variables[name].value\n      return ret\n    } else {\n      throw new Error(`${chalk.cyan(name)} is not defined`)\n    }\n  } else if (expression[0] === C.VARIABLE_ASSIGN) {\n    // Set a variable to a value: \"name => value\"\n\n    // Get the name and value expression from the expression list.\n    const name = expression[1]\n    const valueExpression = expression[2]\n\n    // console.log(`Setting variable ${name}...`)\n\n    // Evaluate the value of the variable.\n    const value = await evaluateExpression(valueExpression, variables)\n\n    // console.log(`..value is ${value}`)\n\n    // Set the variable in the variables object to a new variable with the\n    // evaluated value.\n    variables[name] = new lib.Variable(value)\n    return\n  } else if (expression[0] === C.VARIABLE_CHANGE) {\n    // Change a variable to a new value: \"name -> newValue\"\n\n    // Get the name and value expression from the expression list.\n    const name = expression[1]\n    const valueExpression = expression[2]\n\n    // Evaluate the new value of the variable.\n    const value = await evaluateExpression(valueExpression, variables)\n\n    // Change the value of the already defined variable.\n    variables[name].value = value\n    return\n  } else if (expression[0] === C.FUNCTION_PRIM) {\n    // A function literal: \"[async] [(arg1, arg2, arg3...)] { code }\"\n\n    // Get the code and paramaters from the expression list.\n    const paramaters = expression[1]\n    const code = expression[2]\n    const isAsync = expression[3]\n\n    // Create the function using the given code.\n    const fn = new lib.LFunction(code)\n\n    // Set the scope variables for the function to a copy of the current\n    // variables.\n    fn.setScopeVariables(Object.assign({}, variables))\n\n    // Set the paramaters for the function to the paramaters taken from the\n    // expression list.\n    fn.setParamaters(paramaters)\n\n    fn.isAsynchronous = isAsync\n\n    // Return the function.\n    return fn\n  } else if (expression[0] === C.SHORTHAND_FUNCTION_PRIM) {\n    const paramaters = expression[1]\n    const codeExpression = expression[2]\n    const fn = new lib.LFunction(codeExpression)\n    fn.isShorthand = true\n    fn.setScopeVariables(Object.assign({}, variables))\n    fn.setParamaters(paramaters)\n    return fn\n  } else if (expression[0] === C.STRING_PRIM) {\n    // String literal: \"contents\"\n\n    // Get string from expression list.\n    const string = expression[1]\n\n    // Convert string to a language-usable string, and return.\n    return lib.toLString(string)\n  } else if (expression[0] === C.BOOLEAN_PRIM) {\n    // Boolean literal: true/false\n\n    // Get boolean value from expression list.\n    const bool = expression[1]\n\n    // Convert boolean value to a language-usable boolean, and return.\n    return lib.toLBoolean(bool)\n  } else if (expression[0] === C.NUMBER_PRIM) {\n    // Number primitive: 1, 2, 3, 4, 7.25, -3, etc.\n\n    // Get number value from expression list.\n    const number = expression[1]\n\n    // Convert number value to a language-usable number, and return.\n    return lib.toLNumber(number)\n  } else if (expression[0] === C.SET_PROP_USING_IDENTIFIER) {\n    // Set a property of an object using an identifier literal:\n    // \"obj.key > value\"\n\n    // Get object expression, key, and value expression from expression list.\n    const objExpression = expression[1]\n    const key = expression[2]\n    const valueExpression = expression[3]\n\n    // Evaluate the object and value expressions.\n    const obj = await evaluateExpression(objExpression, variables)\n    const value = await evaluateExpression(valueExpression, variables)\n\n    // Use lib.set to set the property of the evaluated object.\n    lib.set(obj, key, value)\n    return\n  } else if (expression[0] === C.GET_PROP_USING_IDENTIFIER) {\n    // Get a property of an object using an identifier literal: \"obj.key\"\n\n    // Get object expression and key from the expression list.\n    const objExpression = expression[1]\n    const key = expression[2]\n\n    // Evaluate the object expression.\n    const obj = await evaluateExpression(objExpression, variables)\n\n    // Get the value from lib.get.\n    const value = lib.get(obj, key)\n\n    // Return the gotten value.\n    return value\n  } else {\n    throw new Error(`Invalid expression: ${chalk.cyan(expression[0])}`)\n  }\n}\n\nexport async function evaluateGetPropUsingIdentifier(variables, [_, objExpr, key]) {\n  let obj = await evaluateExpression(objExpr, variables)\n  return lib.get(obj, key)\n}\n\nexport async function evaluateEachExpression(variables, expressions) {\n  let results = []\n  for (let expression of expressions) {\n    results.push(await evaluateExpression(expression, variables))\n  }\n  return results\n}\n\nexport async function interp(ast, dir) {\n  if (ast) {\n    const environment = new lib.LEnvironment()\n\n    environment.addVars(builtins.makeBuiltins(dir))\n\n    let result = await evaluateEachExpression(environment, ast)\n\n    return { result, environment }\n  } else {\n    throw new Error('Haha, you didn\\'t pass me a tree!')\n  }\n}\n"],"sourceRoot":"/source/"}